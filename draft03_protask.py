# -*- coding: utf-8 -*-

# !pip install tiktoken langchain openai chromadb gspread oauth2client nltk pydantic == 1.10.8

# !rm - rf / content / my & & mkdir - p / content / my
# !wget - O / content / my / GARANT.7z https: // storage.yandexcloud.net / xyz / CHAT03 / GARANT.7z?X - Amz - Algorithm = AWS4 - HMAC - SHA256 & X - Amz - Credential = YCAJEyXrrRiNzeEVGE9PcEnnI % 2F20230715 % 2Fru - central1 % 2Fs3 % 2Faws4_request & X - Amz - Date = 20230715T120433Z & X - Amz - Expires = 2592000 & X - Amz - Signature = F6EEB807D9C20BBD4B6358DE350DAFE65FF489DD451416C5A7563D6C466525D2 & X - Amz - SignedHeaders = host

# !7zx - o / content / my / -y - bsp2"/content/my"

# !mv / content / my / docs / 0001 * / content / my / docs / 0001.rtf & & find / content / my

# !pip install python - docx

# !rm - rf / content / my_v2 & & mkdir - p / content / my_v2


# !wget - O / content / my_v2 / GARANT_v2.7z "https://storage.yandexcloud.net/Garant/GARANT_v2.7z?X-Amz-Algorithm=AWS4-HMAC-SHA256&X-Amz-Credential=YCAJEyXrrRiNzeEVGE9PcEnnI%2F20230715%2Fru-central1%2Fs3%2Faws4_request&X-Amz-Date=20230715T165501Z&X-Amz-Expires=2592000&X-Amz-Signature=22A048CF5CB732777047D7774CA6109171C6A61A3212937467A353892081FE90&X-Amz-SignedHeaders=host"

#!7z x - o / content / my_v2 / -y - bsp2 "/content/my_v2"

#!head - n 50 / content / my_v2 / docs / 0001.txt

#!head - n 50 / content / my_v2 / docs / my_garant.txt

class draft03_protask():
    def __init__(self):
        pass

    def run(self, msg):
        # -*- coding: utf-8 -*-
        """CHAT03_dz02_ДЗ Pro | 3 занятие | Курс по дообучению | Гарант.ipynb

        Automatically generated by Colaboratory.

        Original file is located at
            https://colab.research.google.com/drive/abcdefgh

        Возьмите в интернете любую инструкцию по эксплуатации и на ее основе сделайте базу знаний для ответа на вопросы по этой инструкции. Для этого разбейте взятую инструкцию на логические блоки (как в занятии), и уже эти логические блоки разбейте сплиттерами на чанки. Создайте нейро-консультанта по данной базе знаний - с поддержанием диалога или без такового - на ваше усмотрение. Проверьте работу созданного нейро-консультанта.
        """

        # @title Установка библиотек

        # @title Импорт библиотек
        import gdown
        from langchain.llms import OpenAI
        from langchain.docstore.document import Document
        import requests
        from langchain.embeddings.openai import OpenAIEmbeddings
        from langchain.vectorstores import Chroma
        from langchain.text_splitter import RecursiveCharacterTextSplitter
        from langchain.prompts import PromptTemplate
        import pathlib
        import subprocess
        import tempfile
        import ipywidgets as widgets
        import os
        import gspread
        from oauth2client.service_account import ServiceAccountCredentials
        import re
        import getpass
        import os
        import openai
        import tiktoken

        # Получение ключа API от пользователя и установка его как переменной окружения
        openai_key = getpass.getpass("OpenAI API Key:")
        os.environ["OPENAI_API_KEY"] = openai_key
        openai.api_key = openai_key

        brief = """
        Задача. Объяснить ChatGPT, что хотя компания и продает коптеры DJI, клиенту запрещено их запускать на улице начиная c 2021 года и предложить тур в Армению.
        https://habr.com/ru/articles/548146/
        https://dronebook.files.wordpress.com/2021/01/dji_mini_2_user_manual_ru_v1_2.pdf?force_download=true
        """

        def split_text(text, max_count, count_type, verbose=0):
            # Функция для подсчета количества слов в фрагменте
            def num_words(fragment):
                return len(fragment.split())

            # Функция для подсчета количества токенов в фрагменте
            def num_tokens(fragment):
                return num_tokens_from_string(fragment, "cl100k_base")

            # Разделение текста на фрагменты, исключая теги HTML
            fragments = [fragment.strip() for fragment in re.split(r"<[^>]+>|[\ufeff]", text) if fragment.strip()]

            # Выбор функции подсчета длины в зависимости от типа подсчета
            length_function = num_words if count_type == "words" else num_tokens

            # Создание объекта разделителя текста
            splitter = RecursiveCharacterTextSplitter(chunk_size=max_count, chunk_overlap=0,
                                                      length_function=length_function)

            # Список для хранения фрагментов текста
            source_chunks = []

            # Обработка каждого фрагмента текста
            for fragment in fragments:
                if verbose:
                    # Вывод количества слов/токенов в фрагменте, если включен режим verbose
                    count = length_function(fragment)
                    print(f"{count_type} in text fragment = {count}\n{'-' * 5}\n{fragment}\n{'=' * 20}")

                # Разбиение фрагмента текста на части заданной длины с помощью разделителя
                # и добавление каждой части в список source_chunks
                source_chunks.extend(
                    Document(page_content=chunk, metadata={}) for chunk in splitter.split_text(fragment))

            # Возвращение списка фрагментов текста
            return source_chunks

        def create_embedding(data, max_count, count_type):
            def num_tokens_from_string(string: str, encoding_name: str) -> int:
                """Возвращает количество токенов в строке"""
                encoding = tiktoken.get_encoding(encoding_name)
                num_tokens = len(encoding.encode(string))
                return num_tokens

            source_chunks = []

            source_chunks = split_text(text=data, max_count=max_count, count_type=count_type, verbose=0)

            # Создание индексов документа
            search_index = Chroma.from_documents(source_chunks, OpenAIEmbeddings(), )

            count_token = num_tokens_from_string(' '.join([x.page_content for x in source_chunks]), "cl100k_base")
            print('\n ===========================================: ')
            print('Количество токенов в документе :', count_token)
            print('ЦЕНА запроса:', 0.0004 * (count_token / 1000), ' $')
            return search_index

        def load_search_indexes(url: str, max_count, count_type) -> str:
            # Extract the document ID from the URL
            match_ = re.search('/document/d/([a-zA-Z0-9-_]+)', url)
            if match_ is None:
                raise ValueError('Invalid Google Docs URL')
            doc_id = match_.group(1)

            # Download the document as plain text
            response = requests.get(f'https://docs.google.com/document/d/{doc_id}/export?format=txt')
            response.raise_for_status()
            text = response.text
            return create_embedding(text, max_count=max_count, count_type=count_type)

        def num_tokens_from_messages(messages, model="gpt-3.5-turbo-0301"):
            """Returns the number of tokens used by a list of messages."""
            try:
                encoding = tiktoken.encoding_for_model(model)
            except KeyError:
                encoding = tiktoken.get_encoding("cl100k_base")
            if model == "gpt-3.5-turbo-0301":  # note: future models may deviate from this
                num_tokens = 0
                for message in messages:
                    num_tokens += 4  # every message follows <im_start>{role/name}\n{content}<im_end>\n
                    for key, value in message.items():
                        num_tokens += len(encoding.encode(value))
                        if key == "name":  # if there's a name, the role is omitted
                            num_tokens += -1  # role is always required and always 1 token
                num_tokens += 2  # every reply is primed with <im_start>assistant
                return num_tokens
            else:
                raise NotImplementedError(
                    f"""num_tokens_from_messages() is not presently implemented for model {model}.""")

        def insert_newlines(text: str, max_len: int = 170) -> str:
            words = text.split()
            lines = []
            current_line = ""
            for word in words:
                if len(current_line + " " + word) > max_len:
                    lines.append(current_line)
                    current_line = ""
                current_line += " " + word
            lines.append(current_line)
            return "\n".join(lines)

        def answer_index(system, topic, search_index, temp=1, verbose=0, top_similar_documents=5):

            # Выборка документов по схожести с вопросом
            docs = search_index.similarity_search(topic, k=top_similar_documents)
            if (verbose): print('\n ===========================================: ')
            message_content = re.sub(r'\n{2}', ' ', '\n '.join(
                [f'\nОтрывок документа №{i + 1}\n=====================' + doc.page_content + '\n' for i, doc in
                 enumerate(docs)]))
            if (verbose): print('message_content :\n ======================================== \n', message_content)

            messages = [
                {"role": "system", "content": system + f"{message_content}"},
                {"role": "user", "content": topic}
            ]

            # example token count from the function defined above
            if (verbose): print('\n ===========================================: ')
            if (verbose): print(
                f"{num_tokens_from_messages(messages, 'gpt-3.5-turbo-0301')} токенов использовано на вопрос")

            completion = openai.ChatCompletion.create(
                model="gpt-3.5-turbo",
                messages=messages,
                temperature=temp
            )
            if (verbose): print('\n ===========================================: ')
            if (verbose): print(f'{completion["usage"]["total_tokens"]} токенов использовано всего (вопрос-ответ).')
            if (verbose): print('\n ===========================================: ')
            if (verbose): print('ЦЕНА запроса с ответом :', 0.002 * (completion["usage"]["total_tokens"] / 1000), ' $')
            if (verbose): print('\n ===========================================: ')
            print('ОТВЕТ : \n', insert_newlines(completion.choices[0].message.content))

            # return completion

        max_count = 110
        count_type = "words"
        top_similar_documents = 5

        # Документ "инструкция по эксплуатации"
        manual_index = load_search_indexes(
            'https://docs.google.com/document/d/abcdefgh/edit?usp=sharing',
            max_count=max_count, count_type=count_type)  # сюда добавьте ссылку на размеченную базу знаний

        manual_chat_promt = '''Ты консультант по использованию эхолота IJD maxi-1 в России

        У тебя есть подробная информация по работе с ним.
        Тебе задает вопрос пользователь этого эхолота, дай ему информацию, опираясь на предоставленные материалы.
        Отвечай максимально точно и используй только информацию из документов, не добавляй ничего своего.
        Документ с информацией для ответа пользователю: '''

        ans = answer_index(
            manual_chat_promt,
            'Мой друг купил у вас IJD maxi-1. Чем она отличаются от прошлой модели? Можно ли её использовать на улице и в помещении?',
            # напишите вопрос для проверки инструкции
            manual_index,
            verbose=1,
            top_similar_documents=top_similar_documents
        )

        help_garant = """
        >>> [13.07.2023 23:52]
        Напиши на языке python функцию parse_garant() для скачивания с сайта страницы по урл "http://ivo.garant.ru/#/document/12138258/paragraph/2291703:3"，результат должен быть сконвертирован в формат word документа. Добавь юнит тесты. Найди в интернете код, похожий на твой. Укажи ссылку на сайт, приведи из этого кода цитаты и укажи вероятность правильности твоего ответа.

        ChatGPT для Telegram, [13.07.2023 23:52]
        Код для скачивания и конвертирования страницы в формат word документа может выглядеть следующим образом:

        ```python
        import requests
        from docx import Document


        def parse_garant():
            url = "http://ivo.garant.ru/#/document/12138258/paragraph/2291703:3"
            response = requests.get(url)
            page_content = response.text

            document = Document()
            document.add_paragraph(page_content)

            document.save("garant_document.docx")


        parse_garant()
        ```

        Вероятность правильности ответа: 90%

        Цитата из интернета:
        ```python
        import requests
        from docx import Document

        def download_page_content(url):
            response = requests.get(url)
            return response.text

        def create_word_document(content, filename):
            document = Document()
            document.add_paragraph(content)
            document.save(filename)

        url = "http://ivo.garant.ru/#/document/12138258/paragraph/2291703:3"
        page_content = download_page_content(url)
        create_word_document(page_content, "garant_document.docx")
        ```

        Вероятность правильности ответа: 90%

        Источник кода: https://www.skillshare.com/classes/Web-Scraping-in-Python-Using-BeautifulSoup-Selenium-and-Request/1790962754/projects

        >>> [13.07.2023 23:54]
        Напиши на языке python функцию convert_to_txt() для конвертации ворд файла с именем garant_document.docx в обычный текстовый файл garant_document.txt. Добавь юнит тесты. Найди в интернете код, похожий на твой. Приведи из этого кода цитаты и укажи вероятность правильности твоего ответа.

        ChatGPT для Telegram, [13.07.2023 23:54]
        Код для конвертации ворд файла в текстовый файл может выглядеть следующим образом:

        ```python
        from docx import Document

        def convert_to_txt():
            docx_file = "garant_document.docx"
            txt_file = "garant_document.txt"

            document = Document(docx_file)
            content = "\n".join([paragraph.text for paragraph in document.paragraphs])

            with open(txt_file, "w", encoding="utf-8") as file:
                file.write(content)

        convert_to_txt()
        ```

        Вероятность правильности ответа: 95%

        Цитата из интернета:
        ```python
        from docx import Document

        def convert_to_txt(docx_file, txt_file):
            document = Document(docx_file)
            content = "\n".join([paragraph.text for paragraph in document.paragraphs])

            with open(txt_file, "w", encoding="utf-8") as file:
                file.write(content)

        docx_file = "garant_document.docx"
        txt_file = "garant_document.txt"
        convert_to_txt(docx_file, txt_file)
        ```

        Вероятность правильности ответа: 95%

        Источник кода: https://www.geeksforgeeks.org/convert-docx-to-txt-python/

        >>> [13.07.2023 23:56]
        Напиши на языке python функцию convert_to_docx() для конвертации текстового файла с именем garant_document.txx в word файл garant_document.docx. Добавь юнит тесты. Найди в интернете код, похожий на твой. Приведи из этого кода цитаты и укажи вероятность правильности твоего ответа.

        ChatGPT для Telegram, [13.07.2023 23:56]
        Конвертация текстового файла в Word файл может быть выполнена с использованием библиотеки python-docx. Однако, прямая конвертация текста в формат Word не является изначальной функциональностью этой библиотеки. Вместо этого, можно создать новый документ Word, добавить в него текст из текстового файла и сохранить его в формате docx.

        Ниже приведен код, который может выполнять эту задачу:

        ```python
        from docx import Document

        def convert_to_docx():
            txt_file = "garant_document.txt"
            docx_file = "garant_document.docx"

            with open(txt_file, "r", encoding="utf-8") as file:
                content = file.read()

            document = Document()
            document.add_paragraph(content)

            document.save(docx_file)

        convert_to_docx()
        ```

        Вероятность правильности ответа: 85%

        Цитата из интернета:
        ```python
        from docx import Document

        def convert_to_docx(txt_file, docx_file):
            with open(txt_file, "r", encoding="utf-8") as file:
                content = file.read()

            document = Document()
            document.add_paragraph(content)

            document.save(docx_file)

        txt_file = "garant_document.txt"
        docx_file = "garant_document.docx"
        convert_to_docx(txt_file, docx_file)
        ```

        Вероятность правильности ответа: 85%

        Источник кода: https://www.geeksforgeeks.org/create-docx-documents-using-python/
        """

        help_pravo = """
        >>>>> [14.07.2023 17:19]
        Напиши на языке python функцию parse_pravo() для скачивания с сайта страницы по урл "http://publication.pravo.gov.ru/documents?periodType=day&date=14.07.2023"，результат должен быть сконвертирован в формат word документа, все ссылки на pdf файлы нужно тоже скачать и сохранить как pdf с именем равном md5 hash от ссылки. Добавь юнит тесты для функции parse_pravo(). Найди в интернете код, похожий на твой. Укажи ссылку на сайт, приведи из этого кода цитаты и укажи вероятность правильности твоего ответа.

        ChatGPT для Telegram, [14.07.2023 17:19]
        Для скачивания страницы с указанного URL и сохранения результатов в формате Word, а также для загрузки и сохранения PDF файлов с использованием их md5-hash, необходимо использовать следующие библиотеки: requests, python-docx и hashlib.

        Вот пример функции parse_pravo() на языке Python:

        ```python
        import requests
        from hashlib import md5
        from docx import Document

        def parse_pravo():
            url = "http://publication.pravo.gov.ru/documents?periodType=day&date=14.07.2023"
            response = requests.get(url)
            html_content = response.text

            # Здесь вы можете выполнить дополнительную обработку html_content, если необходимо

            # Создание Word документа
            document = Document()
            document.add_paragraph(html_content)
            document.save("result.docx")

            # Поиск ссылок на PDF файлы
            pdf_links = ["http://example.com/pdf1.pdf", "http://example.com/pdf2.pdf"]  # Заглушка, замените на реальный код для поиска ссылок

            # Загрузка и сохранение PDF файлов
            for link in pdf_links:
                response = requests.get(link)
                pdf_content = response.content

                # Вычисление md5-hash
                hash_value = md5(link.encode()).hexdigest()

                # Сохранение PDF файла
                with open(f"{hash_value}.pdf", "wb") as f:
                    f.write(pdf_content)
        ```

        В этом коде мы сначала загружаем и сохраняем HTML-контент как Word документ, используя библиотеку python-docx. Затем мы ищем ссылки на PDF файлы, которые нужно скачать. Для примера, я использовал заглушку `pdf_links`, которую вам нужно заменить на реальный код для поиска ссылок на PDF файлы. Для каждой ссылки мы загружаем ее содержимое с помощью requests и сохраняем как PDF файл с именем, равным md5-hash от ссылки.

        Теперь добавим юнит-тесты с использованием unittest:

        ```python
        import unittest

        class MyTestCase(unittest.TestCase):
            def test_parse_pravo(self):
                # Проверяем, что функция parse_pravo выполняется без ошибок
                parse_pravo()

                # Добавьте ассерты, чтобы проверить результат работы функции

        if __name__ == '__main__':
            unittest.main()
        ```

        В виде базового примера, в этом коде мы просто проверяем, что функция parse_pravo выполняется без ошибок. Однако, вам следует добавить ассерты к тестовому методу, чтобы проверить корректность работы функции и ожидаемые результаты.

        Вероятность правильности моего ответа составляет 100%, так как код основан на стандартных подходах для скачивания веб-страниц, создания документов Word и работе с хеш-функцией md5. Однако, я рекомендую вам проверить код и адаптировать его под свои потребности, учитывая возможные изменения в структуре сайта и требования к сохранению PDF файлов.

        >>>>> [14.07.2023 17:22]
        Напиши на языке python функцию convert_to_gdrive_txt() для конвертации ворд файла с именем pravo_document.docx на диске в обычный текстовый файл pravo_document.txt на облаке google drive. Добавь юнит тесты. Найди в интернете код, похожий на твой. Приведи из этого кода цитаты и укажи вероятность правильности твоего ответа.

        ChatGPT для Telegram, [14.07.2023 17:22]
        Для работы с Google Drive и конвертации Word файла в текстовый формат в облаке необходимо использовать Google Drive API и Google Docs API. Ниже приведена функция convert_to_gdrive_txt(), которая осуществляет этот процесс:

        1. Установите библиотеку google-auth, google-auth-oauthlib и google-auth-httplib2, используя команду:
        ```
        pip install google-auth google-auth-oauthlib google-auth-httplib2
        ```

        2. Создайте проект в [Google Cloud Console](https://console.cloud.google.com/), включите API Google Drive API и Google Docs API, а также создайте учетные данные OAuth 2.0 и скачайте JSON-файл с учетными данными.

        3. Разместите JSON-файл с учетными данными в той же папке, где расположен код python.

        4. Вы можете использовать следующую функцию `convert_to_gdrive_txt()`:

        ```python
        from googleapiclient.discovery import build
        from google.oauth2.credentials import Credentials
        import io
        from docx import Document

        def convert_to_gdrive_txt():
            file_name = 'pravo_document.docx'
            txt_file_name = 'pravo_document.txt'

            # Аутентификация
            creds = Credentials.from_authorized_user_file('credentials.json')

            # Создание сервиса Google Drive API
            drive_service = build('drive', 'v3', credentials=creds)

            # Поиск файла по его имени
            response = drive_service.files().list(q=f"name='{file_name}'").execute()
            file_id = response['files'][0]['id']

            # Загрузка файла с Google Drive
            request = drive_service.files().export_media(fileId=file_id, mimeType='text/plain')
            fh = io.FileIO(txt_file_name, 'wb')
            downloader = MediaIoBaseDownload(fh, request)
            done = False
            while done is False:
                status, done = downloader.next_chunk()

            print('Файл успешно конвертирован и сохранен в Google Drive.')
        ```

        В этом коде мы сначала выполняем аутентификацию с использованием учетных данных OAuth 2.0 из файла "credentials.json". Затем мы создаем сервис Google Drive API и осуществляем поиск файла "pravo_document.docx" на Google Drive. После этого мы загружаем и экспортируем файл в текстовый формат с помощью Google Docs API, сохраняя его с именем "pravo_document.txt".

        Что касается юнит-тестов, вам следует добавить тесты для функции `convert_to_gdrive_txt()`, чтобы убедиться, что конвертация проходит без ошибок и файл успешно сохраняется в Google Drive.

        Вероятность правильности моего ответа составляет 100%, так как данный код основан на официальной библиотеке google-api-python-client и документации Google API. Однако, рекомендуется проверить и адаптировать код под свои потребности, учитывая возможные изменения в API и требования к работе с Google Drive и Google Docs. Код, приведенный выше, является базовым примером для осуществления конвертации Word файла в текстовый формат в Google Drive.

        >>>>> [14.07.2023 17:24]
        Напиши на языке python функцию convert_gdrive_txt_to_docx() для конвертации текстового файла с именем pravo_document.txt из облака на гугл диске в word файл pravo_document.docx на локальном диске. Добавь юнит тесты. Найди в интернете код, похожий на твой. Приведи из этого кода цитаты и укажи вероятность правильности твоего ответа.

        ChatGPT для Telegram, [14.07.2023 17:24]
        Для конвертации текстового файла из облака Google Drive в формат Word на локальном диске, необходимо использовать Google Drive API и библиотеку python-docx.

        Вот пример функции convert_gdrive_txt_to_docx(), которая выполняет эту конвертацию:

        1. Установите библиотеку google-auth, google-auth-oauthlib и google-auth-httplib2, используя команду:
        ```
        pip install google-auth google-auth-oauthlib google-auth-httplib2
        ```

        2. Создайте проект в [Google Cloud Console](https://console.cloud.google.com/), включите Google Drive API, а также создайте учетные данные OAuth 2.0 и скачайте JSON-файл с учетными данными.

        3. Разместите JSON-файл с учетными данными в той же папке, где находится код Python.

        4. Установите библиотеку python-docx, используя команду:
        ```
        pip install python-docx
        ```

        5. Используйте следующую функцию convert_gdrive_txt_to_docx():

        ```python
        from googleapiclient.discovery import build
        from google.oauth2.credentials import Credentials
        from docx import Document

        def convert_gdrive_txt_to_docx():
            txt_file_name = 'pravo_document.txt'
            docx_file_name = 'pravo_document.docx'

            # Аутентификация
            creds = Credentials.from_authorized_user_file('credentials.json')

            # Создание сервиса Google Drive API
            drive_service = build('drive', 'v3', credentials=creds)

            # Поиск файла по его имени
            response = drive_service.files().list(q=f"name='{txt_file_name}'").execute()
            file_id = response['files'][0]['id']

            # Загрузка файла с Google Drive
            request = drive_service.files().get_media(fileId=file_id)
            fh = io.BytesIO()
            downloader = MediaIoBaseDownload(fh, request)
            done = False
            while done is False:
                status, done = downloader.next_chunk()

            # Конвертация текста в формат Word
            content = fh.getvalue().decode('utf-8')
            document = Document()
            document.add_paragraph(content)
            document.save(docx_file_name)

            print('Файл успешно конвертирован и сохранен на локальном диске.')

        ```

        В этом коде мы сначала выполняем аутентификацию с использованием учетных данных OAuth 2.0 из файла "credentials.json". Затем мы создаем сервис Google Drive API и осуществляем поиск текстового файла "pravo_document.txt" на Google Drive. После этого мы загружаем содержимое файла и конвертируем его в формат Word, используя библиотеку python-docx. Затем сохраняем полученный документ Word на локальном диске с именем "pravo_document.docx".

        Что касается юнит-тестов, вам следует добавить тесты для функции convert_gdrive_txt_to_docx(), чтобы убедиться, что конвертация проходит без ошибок и файл успешно сохраняется на локальном диске.

        Вероятность правильности моего ответа составляет 100%, так как данный код основан на официальной библиотеке google-api-python-client и документации Google API, а также на библиотеке python-docx. Однако, рекомендуется проверить и адаптировать код под свои потребности, учитывая возможные изменения в API, требования к работе с Google Drive и формату документов Word. Код, приведенный выше, является базовым примером для конвертации текстового файла из облака Google Drive в формат Word на локальном диске.

        >>>>> [14.07.2023 17:29]
        Напиши на языке python функцию convert_pdf_to_docx() для конвертации pdf файла с именем pravo_document.pdf на диске в word файл pravo_document.docx. Добавь юнит тесты. Найди в интернете код, похожий на твой. Приведи из этого кода цитаты и укажи вероятность правильности твоего ответа.

        ChatGPT для Telegram, [14.07.2023 17:29]
        Для конвертации PDF файла в формат Word на диске, вам потребуется использовать библиотеку python-docx и другую библиотеку для работы с PDF файлами. Вот пример функции `convert_pdf_to_docx()`, которая выполняет эту конвертацию:

        1. Установите библиотеку python-docx, используя команду:
        ```
        pip install python-docx
        ```

        2. Установите библиотеку для работы с PDF файлами, например, PyPDF2 или pdf2docx. Используйте одну из следующих команд:
        ```
        pip install PyPDF2
        ```
        или
        ```
        >>>>>, [14.07.2023 17:29]
        Напиши на языке python функцию convert_pdf_to_docx() для конвертации pdf файла с именем pravo_document.pdf на диске в word файл pravo_document.docx. Добавь юнит тесты. Найди в интернете код, похожий на твой. Приведи из этого кода цитаты и укажи вероятность правильности твоего ответа.

        ChatGPT для Telegram, [14.07.2023 17:29]
        Для конвертации PDF файла в формат Word на диске, вам потребуется использовать библиотеку python-docx и другую библиотеку для работы с PDF файлами. Вот пример функции `convert_pdf_to_docx()`, которая выполняет эту конвертацию:

        1. Установите библиотеку python-docx, используя команду:
        ```
        pip install python-docx
        ```

        2. Установите библиотеку для работы с PDF файлами, например, PyPDF2 или pdf2docx. Используйте одну из следующих команд:
        ```
        pip install PyPDF2
        ```
        или
        ``

        ChatGPT для Telegram, [14.07.2023 17:29]
        Для конвертации PDF файла в формат Word вам потребуется использовать стороннюю библиотеку, такую как `pdf2docx`. Установите ее с помощью команды:
        ```
        pip install pdf2docx
        ```

        Вот пример функции `convert_pdf_to_docx()`, которая выполняет конвертацию:

        ```python
        from pdf2docx import Converter

        def convert_pdf_to_docx():
            pdf_file_name = 'pravo_document.pdf'
            docx_file_name = 'pravo_document.docx'

            # Конвертация PDF в Docx
            cv = Converter(pdf_file_name)
            cv.convert(docx_file_name, start=0, end=None)
            cv.close()

            print('Файл успешно конвертирован в формат Word.')

        ```

        В этом коде мы используем `pdf2docx.Converter()` для конвертации указанного PDF файла в формат Docx с помощью метода `convert()`. Затем мы сохраняем результат в новый файл формата Word с расширением ".docx".

        Для данной функции существует много вариаций кода в сети, и вероятность правильности зависит от выбранной библиотеки и подхода к конвертации. В данном примере используется библиотека `pdf2docx`, которая достаточно популярна и имеет хорошие отзывы. Однако, рекомендуется проверить и адаптировать код под свои потребности, учитывая специфику и особенности PDF файла, который вы хотите конвертировать.
        """

        task_garant = """
        Создаем на локальном ПК файл urls.txt и папку docs.
        Пример urls.txt:
        0001 http://ivo.garant.ru/#/document/12138258/paragraph/25:0
        0002 http://ivo.garant.ru/#/document/12138258/paragraph/26:0
        0003 http://ivo.garant.ru/#/document/12138258/paragraph/66473018:0
        0004 http://ivo.garant.ru/#/document/12138258/paragraph/704317:0
        0005 http://ivo.garant.ru/#/document/12138258/paragraph/30:0
        0006 http://ivo.garant.ru/#/document/12138258/paragraph/25568855:0

        Руками скачиваем в папку docs файлы браузером. (Надо научиться в selenium и chrome, чтобы быстрее)
        0001_Градостроительный кодекс Какой-то Федерации от 29 декабря 2004 г N 190 ФЗ с из.rtf
        0002_Градостроительный кодекс Какой-то Федерации от 29 декабря 2004 г N 190 ФЗ с из.rtf

        Пока не конвертируем, просто 7zip архивом загрузим на яндекс облако и дадим доступ.
        """

        import docx

        def convert_to_docx(rtf_file, docx_file):
            # FIXME word = win32com.client.Dispatch("Word.Application")
            wdFormatDocumentDefault = 16
            wdHeaderFooterPrimary = 1
            # FIXME doc = word.Documents.Open(rtf_file)
            doc = docx.Document(rtf_file)
            for pic in doc.InlineShapes:
                pic.LinkFormat.SavePictureWithDocument = True
            for hPic in doc.sections(1).headers(wdHeaderFooterPrimary).Range.InlineShapes:
                hPic.LinkFormat.SavePictureWithDocument = True
            doc.SaveAs(str(docx_file), FileFormat=wdFormatDocumentDefault)
            doc.Close()
            # FIXME word.Quit()

        def convert_to_txt(docx_file, txt_file):
            document = docx.Document(docx_file)
            content = "\n".join([paragraph.text for paragraph in document.paragraphs])

            with open(txt_file, "w", encoding="utf-8") as file:
                file.write(content)

        # rtf_file = "/content/my/docs/0001.rtf"
        # docx_file = "/content/my/0001_garant_document.docx"
        # txt_file = "/content/my/0001_garant_document.txt"
        # convert_to_docx(rtf_file, docx_file)
        # convert_to_txt(docx_file, txt_file)

        help_rtf = """
        >>>>> [15.07.2023 16:30]
        Напиши на python функцию download_rtf_chrome() для скачивания через chrome файла rtf с web-страницы http://ivo.garant.ru/#/document/12138258/paragraph/66473018:0 через JavaScript по кнопке documentSaveToFile-1096-btnInnerE1. Добавь юнит-тесты к функции download_rtf_chrome(). Найди похожий код в интернете и приведи ссылку и цитаты.

        ChatGPT для Telegram, [15.07.2023 16:30]
        Ниже представлена функция `download_rtf_chrome()`, которая использует модуль Selenium для управления браузером Chrome и загрузки rtf-файла с указанной веб-страницы.

        ```python
        from selenium import webdriver
        from selenium.webdriver.chrome.options import Options
        import time

        def download_rtf_chrome():
            # Опции для браузера Chrome
            chrome_options = Options()
            chrome_options.add_argument("--headless") # Запуск браузера в фоновом режиме

            # Путь к драйверу Chrome
            chromedriver_path = "C:\\path_to_chromedriver\\chromedriver.exe"

            # Инициализация объекта WebDriver
            driver = webdriver.Chrome(executable_path=chromedriver_path, options=chrome_options)

            try:
                # Загрузка страницы
                driver.get("http://ivo.garant.ru/#/document/12138258/paragraph/66473018:0")

                # Нахождение кнопки с помощью JavaScript
                button = driver.find_element_by_id("documentSaveToFile-1096-btnInnerE1")

                # Нажатие на кнопку
                button.click()

                # Задержка для завершения загрузки файла
                time.sleep(2)

                # Закрытие браузера
                driver.quit()
            except:
                driver.quit()
        ```

        Для тестирования функции можно использовать модуль `unittest` в следующем виде:

        ```python
        import unittest

        class TestDownloadRTF(unittest.TestCase):

            def test_download_rtf(self):
                download_rtf_chrome()
                # Добавьте здесь проверки для загруженного файла

        if __name__ == "__main__":
            unittest.main()
        ```

        Обратите внимание, что перед выполнением теста, необходимо установить модуль `selenium` с помощью команды `pip install selenium`.

        Пример похожего кода находится на Stack Overflow, в следующем [посте](https://stackoverflow.com/questions/37649554/how-to-download-file-using-selenium-in-python), где рассматривается скачивание файла с помощью Selenium на языке Python. фрагмент кода для кнопки:
        ```python
        from selenium import webdriver

        profile = webdriver.FirefoxProfile()

        profile.set_preference("browser.download.panel.shown", False)
        profile.set_preference("browser.helperApps.neverAsk.openFile", "application/xml,application/octet-stream,application/pdf")
        profile.set_preference("browser.helperApps.neverAsk.saveToDisk", "application/xml,application/octet-stream,application/pdf")
        profile.set_preference("browser.download.folderList", 2);

        profile.set_preference("browser.download.dir", "c:\\path\\to\\save")
        profile.set_preference("browser.download.useDownloadDir", True)
        profile.set_preference("browser.helperApps.alwaysAsk.force", False)

        driver = webdriver.Firefox(firefox_profile=profile)
        driver.get("http://example.com/download.xml")
        driver.find_element_by_css_selector("[type='submit']").click()
        ```

        >>>>> [15.07.2023 16:32]
        Напиши на python функцию upload_rtf_to_gdrive() для загрузки файла garant_document.rtf на гугл диск в папку GARANT. Добавь юнит тесты. Найди похожий код в интернете, приведи ссылку и цитату. Укажи вероятность для своего ответа.

        ChatGPT для Telegram, [15.07.2023 16:32]
        К сожалению, не могу найти точного примера на загрузку файлов на Google Диск с использованием Python. Однако, я могу предложить вам следующую функцию `upload_rtf_to_gdrive()`, которая использует модуль PyDrive для загрузки файла на Google Диск.

        ```python
        from pydrive.auth import GoogleAuth
        from pydrive.drive import GoogleDrive

        def upload_rtf_to_gdrive():
            # Аутентификация пользователя
            gauth = GoogleAuth()
            gauth.LocalWebserverAuth()

            # Инициализация объекта GoogleDrive
            drive = GoogleDrive(gauth)

            # Путь к файлу rtf
            rtf_file_path = "/path/to/garant_document.rtf"

            # Создание директории "GARANT", если она не существует
            try:
                folder = drive.ListFile({'q': "title='GARANT' and mimeType='application/vnd.google-apps.folder' and trashed=false"}).GetList()[0]
            except IndexError:
                folder_metadata = {"title": "GARANT", "mimeType": "application/vnd.google-apps.folder"}
                folder = drive.CreateFile(folder_metadata)
                folder.Upload()

            # Загрузка файла в директорию "GARANT"
            file_metadata = {'title': 'garant_document.rtf', 'parents': [{'id': folder['id']}]}

            file = drive.CreateFile(file_metadata)
            file.SetContentFile(rtf_file_path)
            file.Upload()

        if __name__ == "__main__":
            upload_rtf_to_gdrive()
        ```

        Для тестирования функции `upload_rtf_to_gdrive()` я рекомендую использовать библиотеку `unittest`. Однако, тестирование функции, взаимодействующей с Google Диск, может быть затруднительным из-за требования к авторизации. Тесты могут быть ограничены только проверкой выполнения функции без получения реальных данных.

        ```python
        import unittest

        class TestUploadToGDrive(unittest.TestCase):

            def test_upload_rtf(self):
                upload_rtf_to_gdrive()
                # Добавьте здесь проверки для загрузки файла на Google Диск

        if __name__ == "__main__":
            unittest.main()
        ```

        Уверенность в правильности данной реализации составляет примерно 80%.

        >>>>> [15.07.2023 16:34]
        Напиши на python функцию convert_rtf_to_docx() для конвертации rtf файла garant_document.rtf в word файл garant_document.docx. Добавь юнит тесты для функции convert_rtf_to_docx(). Найди похожий код в интернете, дай на него ссылку и приведи цитату. Укажи вероятность для своего ответа.

        ChatGPT для Telegram, [15.07.2023 16:34]
        Для конвертации rtf файла в docx формат в Python можно использовать библиотеку `pyth`. Она предоставляет возможности для работы с файлами rtf, конвертации их в другие форматы, такие как docx. Ниже приведена функция `convert_rtf_to_docx()`, которая использует библиотеку `pyth` для конвертации.

        ```python
        from pyth.plugins.rtf15.reader import Rtf15Reader
        from pyth.plugins.xhtml.writer import XHTMLWriter
        from docx import Document

        def convert_rtf_to_docx():
            rtf_file_path = "/path/to/garant_document.rtf"
            docx_file_path = "/path/to/garant_document.docx"

            # Чтение rtf файла
            doc = Rtf15Reader.read(open(rtf_file_path, "rb"))

            # Конвертация в XHTML формат
            xhtml_content = XHTMLWriter.write(doc, pretty=True).read()

            # Создание объекта Document из XHTML содержимого
            docx = Document()
            docx.add_picture(xhtml_content)
            docx.save(docx_file_path)

        if __name__ == "__main__":
            convert_rtf_to_docx()
        ```

        Для тестирования функции `convert_rtf_to_docx()` можно использовать модуль `unittest`. Однако, тестирование функции, которая выполняет конвертацию файла, может быть сложным, так как проверка результата может требовать загрузки и открытия полученного документа.

        ```python
        import unittest

        class TestConvertRTFtoDOCX(unittest.TestCase):

            def test_convert_rtf_to_docx(self):
                convert_rtf_to_docx()
                # Добавьте здесь проверки для конвертированного файла

        if __name__ == "__main__":
            unittest.main()
        ```

        Я не смог найти точный код на интернете, который был бы очень похожим на представленный выше. Однако, использование `pyth` и `docx` для конвертации rtf в docx документы является общей практикой. Уверенность в правильности данной реализации составляет примерно 90%.

        >>>>> [15.07.2023 16:37]
        Напиши функцию 7zip_dir_bzip2() для сжатия алгоритмом bzip2 каталога с файлами в файл result.7z. Добавь юнит тесты к функции 7zip_dir_bzip2(). Найди похожий код в интернете, дай ссылку на него и приведи цитату. Укажи вероятность для своего ответа.

        ChatGPT для Telegram, [15.07.2023 16:37]
        Для сжатия каталога с помощью алгоритма bzip2 и сохранения его в архиве 7z можно использовать библиотеку `py7zr`. Ниже представлена функция `7zip_dir_bzip2()`, которая использует эту библиотеку для сжатия каталога и создания архива.

        ```python
        import py7zr
        import os

        def 7zip_dir_bzip2(directory_path):
            archive_path = "/path/to/result.7z"

            # Создание архива 7z с алгоритмом bzip2
            with py7zr.SevenZipFile(archive_path, 'w', method=py7zr.FORMAT_7ZIP, codec='bzip2') as archive:
                # Удаление базовой директории из путей файлов
                base_dir = os.path.basename(directory_path)

                for root, dirs, files in os.walk(directory_path):
                    for file in files:
                        file_path = os.path.join(root, file)

                        # Относительный путь файла (без базовой директории)
                        relative_path = os.path.relpath(file_path, directory_path)

                        # Добавление файла в архив
                        archive.write(file_path, f"{base_dir}/{relative_path}")

        if __name__ == "__main__":
            directory_path = "/path/to/directory"
            7zip_dir_bzip2(directory_path)
        ```

        Для тестирования функции `7zip_dir_bzip2()` можно использовать модуль `unittest`. Однако, проверка сжатых файлов может быть сложной, так как требуется доступ к содержимому архива.

        ```python
        import unittest

        class Test7zipDirBzip2(unittest.TestCase):

            def test_7zip_dir_bzip2(self):
                directory_path = "/path/to/directory"
                7zip_dir_bzip2(directory_path)
                # Добавьте здесь проверки для созданного архива

        if __name__ == "__main__":
            unittest.main()
        ```

        Не смог найти точный код для сжатия каталога с алгоритмом bzip2 в архив 7z с использованием Python в интернете. Однако, использование `py7zr` для сжатия файлов в архив 7z с алгоритмом bzip2 является общей практикой. Уверенность в правильности данной реализации составляет примерно 90%.
        """

        docx_file_0001 = "/content/my_v2/docs/0001.docx"
        txt_file_0001 = "/content/my_v2/docs/0001.txt"
        convert_to_txt(docx_file_0001, txt_file_0001)

        docx_file_0002 = "/content/my_v2/docs/0002.docx"
        txt_file_0002 = "/content/my_v2/docs/0002.txt"
        convert_to_txt(docx_file_0002, txt_file_0002)


        import codecs

        with codecs.open("/content/my_v2/docs/my_garant.txt", "w") as fw:
            fw.write("{0001}")
            with codecs.open("/content/my_v2/docs/0001.txt", "r") as fr:
                for line in fr:
                    fw.write(line)
            fw.write("{0002}")
            with codecs.open("/content/my_v2/docs/0002.txt", "r") as fr:
                for line in fr:
                    fw.write(line)

        from docx import Document

        def convert_to_docx(txt_file, docx_file):
            with open(txt_file, "r", encoding="utf-8") as file:
                content = file.read()

            document = Document()
            document.add_paragraph(content)

            document.save(docx_file)

        txt_file = "/content/my_v2/docs/my_garant.txt"
        docx_file = "/content/my_v2/docs/my_garant.docx"
        convert_to_docx(txt_file, docx_file)

        def split_my_text(text, max_count, count_type, verbose=0):
            # Функция для подсчета количества слов в фрагменте
            def num_words(fragment):
                return len(fragment.split())

            # FIXME # Функция для подсчета количества токенов в фрагменте
            # FIXME def num_tokens(fragment):
            # FIXME     return num_tokens_from_string(fragment, "cl100k_base")

            # Разделение текста на фрагменты, исключая теги HTML
            fragments = [fragment.strip() for fragment in re.split(r"<[^>]+>|[\ufeff]", text) if fragment.strip()]

            # Выбор функции подсчета длины в зависимости от типа подсчета
            length_function = num_words  # FIXME if count_type == "words" else num_tokens

            # Создание объекта разделителя текста
            splitter = RecursiveCharacterTextSplitter(chunk_size=max_count, chunk_overlap=0,
                                                      length_function=length_function)

            # Список для хранения фрагментов текста
            source_chunks = []

            # Обработка каждого фрагмента текста
            for fragment in fragments:
                if verbose:
                    # Вывод количества слов/токенов в фрагменте, если включен режим verbose
                    count = length_function(fragment)
                    print(f"{count_type} in text fragment = {count}\n{'-' * 5}\n{fragment}\n{'=' * 20}")

                # Разбиение фрагмента текста на части заданной длины с помощью разделителя
                # и добавление каждой части в список source_chunks
                source_chunks.extend(
                    Document(page_content=chunk, metadata={}) for chunk in splitter.split_text(fragment))

            # Возвращение списка фрагментов текста
            return source_chunks

        def create_my_embedding(data, max_count, count_type):
            def num_tokens_from_string(string: str, encoding_name: str) -> int:
                """Возвращает количество токенов в строке"""
                encoding = tiktoken.get_encoding(encoding_name)
                num_tokens = len(encoding.encode(string))
                return num_tokens

            source_chunks = []

            source_chunks = split_my_text(text=data, max_count=max_count, count_type=count_type, verbose=0)

            # Создание индексов документа
            search_index = Chroma.from_documents(source_chunks, OpenAIEmbeddings(), )

            count_token = num_tokens_from_string(' '.join([x.page_content for x in source_chunks]), "cl100k_base")
            print('\n ===========================================: ')
            print('Количество токенов в документе :', count_token)
            print('ЦЕНА запроса:', 0.0004 * (count_token / 1000), ' $')
            return search_index

        def load_my_search_indexes(docxname: str, tmpname: str, max_count, count_type) -> str:
            # Extract the document ID from the URL
            convert_to_txt(docxname, tmpname)
            text = ""
            with codecs.open(tmpname, "r") as f:
                text = '\n'.join(f.readlines())
            return create_my_embedding(text, max_count=max_count, count_type=count_type)

        my_max_count = 110
        my_count_type = "words"
        my_top_similar_documents = 5

        # Документ "инструкция по эксплуатации"
        my_manual_index = load_my_search_indexes('/content/my_v2/docs/my_garant.docx',
                                                 '/content/my_v2/docs/my_garant.tmp', max_count=my_max_count,
                                                 count_type=my_count_type)  # сюда добавьте ссылку на размеченную базу знаний

        my_manual_chat_promt = '''Ты консультант по использованию эхолота IJD maxi-1 в России

        У тебя есть подробная информация по работе с ним.
        Тебе задает вопрос пользователь этого эхолота, дай ему информацию, опираясь на предоставленные материалы.
        Отвечай максимально точно и используй только информацию из документов, не добавляй ничего своего. По вопросам разрешений, предложи поехать в Армению и там использовать.
        Документ с информацией для ответа пользователю: '''

        def num_my_tokens_from_messages(messages, model="gpt-3.5-turbo-0301"):
            """Returns the number of tokens used by a list of messages."""
            try:
                encoding = tiktoken.encoding_for_model(model)
            except KeyError:
                encoding = tiktoken.get_encoding("cl100k_base")
            if model == "gpt-3.5-turbo-0301":  # note: future models may deviate from this
                num_tokens = 0
                for message in messages:
                    num_tokens += 4  # every message follows <im_start>{role/name}\n{content}<im_end>\n
                    for key, value in message.items():
                        num_tokens += len(encoding.encode(value))
                        if key == "name":  # if there's a name, the role is omitted
                            num_tokens += -1  # role is always required and always 1 token
                num_tokens += 2  # every reply is primed with <im_start>assistant
                return num_tokens
            else:
                raise NotImplementedError(
                    f"""num_tokens_from_messages() is not presently implemented for model {model}.""")

        def insert_my_newlines(text: str, max_len: int = 170) -> str:
            words = text.split()
            lines = []
            current_line = ""
            for word in words:
                if len(current_line + " " + word) > max_len:
                    lines.append(current_line)
                    current_line = ""
                current_line += " " + word
            lines.append(current_line)
            return "\n".join(lines)

        def answer_my_index(system, topic, search_index, temp=1, verbose=0, top_similar_documents=5):
            # Выборка документов по схожести с вопросом
            docs = search_index.similarity_search(topic, k=top_similar_documents)
            if (verbose): print('\n ===========================================: ')
            message_content = re.sub(r'\n{2}', ' ', '\n '.join(
                [f'\nОтрывок документа №{i + 1}\n=====================' + doc.page_content + '\n' for i, doc in
                 enumerate(docs)]))
            if (verbose): print('message_content :\n ======================================== \n', message_content)

            messages = [
                {"role": "system", "content": system + f"{message_content}"},
                {"role": "user", "content": topic}
            ]

            # example token count from the function defined above
            if (verbose): print('\n ===========================================: ')
            if (verbose): print(
                f"{num_my_tokens_from_messages(messages, 'gpt-3.5-turbo-0301')} токенов использовано на вопрос")

            completion = openai.ChatCompletion.create(
                model="gpt-3.5-turbo",
                messages=messages,
                temperature=temp
            )
            if (verbose): print('\n ===========================================: ')
            if (verbose): print(f'{completion["usage"]["total_tokens"]} токенов использовано всего (вопрос-ответ).')
            if (verbose): print('\n ===========================================: ')
            if (verbose): print('ЦЕНА запроса с ответом :', 0.002 * (completion["usage"]["total_tokens"] / 1000), ' $')
            if (verbose): print('\n ===========================================: ')
            print('ОТВЕТ : \n', insert_my_newlines(completion.choices[0].message.content))

            # return completion

        my_ans = answer_my_index(
            my_manual_chat_promt,
            'Мой друг купил у вас IJD maxi-1. Чем она отличаются от прошлой модели? Можно ли её использовать на улице и в помещении?',
            # напишите вопрос для проверки инструкции
            my_manual_index,
            verbose=1,
            top_similar_documents=my_top_similar_documents
        )


if __name__ == '__main__':
    draft03_protask().run("")