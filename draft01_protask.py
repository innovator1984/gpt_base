# -*- coding: utf-8 -*-

# !pip install faiss - cpu langchain openai tiktoken

class draft01_protask():
    def __init__(self):
        pass

    def run(self, msg):
        """ДЗ Pro| 1 занятие | Дообучение ChatGPT | Гарант.ipynb

        Automatically generated by Colaboratory.

        Original file is located at
            https://colab.research.google.com/drive/abcdefgh

        На основе базы знаний HR отдела сделайте нейро-консультанта для ответов на вопросы hr-специалистов в компании. Проработайте промпт самостоятельно. Помните, что созданный документ с промптом должен быть с открытым доступом. Проверьте работу нейро-консультанта.
        Документ с базой знаний можно найти тут: https://docs.google.com/document/d/abcdefgh
        """

        from langchain.embeddings.openai import OpenAIEmbeddings
        from langchain.text_splitter import CharacterTextSplitter
        from langchain.vectorstores import FAISS
        from langchain.document_loaders import TextLoader
        import os
        import getpass
        import re
        import requests
        import openai
        from langchain.docstore.document import Document

        # Получение ключа API от пользователя и установка его как переменной окружения
        openai_key = getpass.getpass("OpenAI API Key:")
        os.environ["OPENAI_API_KEY"] = openai_key
        openai.api_key = openai_key

        def load_document_text(url: str) -> str:
            # Extract the document ID from the URL
            match_ = re.search('/document/d/([a-zA-Z0-9-_]+)', url)
            if match_ is None:
                raise ValueError('Invalid Google Docs URL')
            doc_id = match_.group(1)

            # Download the document as plain text
            response = requests.get(f'https://docs.google.com/document/d/{doc_id}/export?format=txt')
            response.raise_for_status()
            text = response.text

            return text

        # Инструкция для GPT, которая будет подаваться в system
        system = load_document_text()  # введите сюда нужное значение

        # База знаний, которая будет подаваться в langChain
        database = load_document_text()  # введите сюда нужное значение

        source_chunks = []
        splitter = CharacterTextSplitter(separator="\n", chunk_size=500, chunk_overlap=0)

        for chunk in splitter.split_text(database):
            source_chunks.append(Document(page_content=chunk, metadata={}))

        # Инициализирум модель эмбеддингов
        embeddings = OpenAIEmbeddings()

        # Создадим индексную базу из разделенных фрагментов текста
        db = FAISS.from_documents(source_chunks, embeddings)

        # Функция, которая позволяет выводить ответ модели в удобочитаемом виде
        def insert_newlines(text: str, max_len: int = 170) -> str:
            words = text.split()
            lines = []
            current_line = ""
            for word in words:
                if len(current_line + " " + word) > max_len:
                    lines.append(current_line)
                    current_line = ""
                current_line += " " + word
            lines.append(current_line)
            return " ".join(lines)

        def answer_index(system, topic, search_index, temp=1, verbose=0):

            # Поиск релевантных отрезков из базы знаний
            docs = search_index.similarity_search(topic, k=4)
            if verbose: print('\n ===========================================: ')
            message_content = re.sub(r'\n{2}', ' ', '\n '.join(
                [f'\nОтрывок документа №{i + 1}\n=====================' + doc.page_content + '\n' for i, doc in
                 enumerate(docs)]))
            if verbose: print('message_content :\n ======================================== \n', message_content)

            messages = [
                {"role": "system", "content": system},
                {"role": "user",
                 "content": f"Документ с информацией для ответа клиенту: {message_content}\n\nВопрос клиента: \n{topic}"}
            ]

            if verbose: print('\n ===========================================: ')

            completion = openai.ChatCompletion.create(
                model="gpt-3.5-turbo",
                messages=messages,
                temperature=temp
            )
            answer = insert_newlines(completion.choices[0].message.content)
            return answer  # возвращает ответ

        temperature =  # введите сюда нужное значение
        verbose =  # введите сюда нужное значение

        # вопрос пользователя
        topic = " "  # введите сюда нужное значение

        ans = answer_index(system, topic, db)
        ans


if __name__ == '__main__':
    draft01_protask().run("")